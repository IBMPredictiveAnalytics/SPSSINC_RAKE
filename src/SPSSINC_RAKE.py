

#Licensed Materials - Property of IBM
#IBM SPSS Products: Statistics General
#(c) Copyright IBM Corp. 2009, 2020
#US Government Users Restricted Rights - Use, duplication or disclosure 
#restricted by GSA ADP Schedule Contract with IBM Corp.

__author__ = "SPSS, JKP"
__version__ = "2.7.0"

# 05-aug-2010 handle unlicensed module error
# 26-aug-2011 force delta = 0 for 1-d problem.  Improve genlog failure error message.
# 22-dec-2011 up number of dimensions from 5 to 10
# 07-feb-2012 add balance calculation and output weight table
# 16-apr-2012 remove weights for which there are no cases from output table
# 20-apr-2012 preserve input weight variability and match output marginals
# 08-apr-2015 add option to show or hide table of weights
# 10-apr-2015 add option to get control totals from datasets
# 25-jun-2015 allow expressions for control totals
# 22-nov-2015 add optional heatmap and histogram

import spss, spssaux, spssdata
from extension import Template, Syntax, checkrequiredparams, processcmd
import random, re, locale

helptext="""SPSSINC RAKE DIM1=control spec
  [DIM2=control spec]
  [DIM3=control spec]
  [DIM4=control spec]
  [DIM5=control spec]
  [DIM6=control spec]
  [DIM7=control spec]
  [DIM8=control spec]
  [DIM9=control spec]
  [DIM10=control spec]  
  FINALWEIGHT=varname
  [POPTOTAL=value]
[/OPTIONS [DELTA=value] [ITERATIONS=value][CONVERGENCE=value  [CHECKEMPTY={YES*|NO}]
  [SHOW]

Example:
SPSSINC RAKE DIM1 = jobcat 1 500 2 300 3 200.

Up to 10 control total dimensions can be specified using DIM1, ..., DIM10.
Each DIM specification consists of a variable name followed by
a list of category values and the total or fraction for that category.
Only numeric variables can be used for control totals.
Note: with many dimensions this command might run out of memory on 32-bit systems 
and take a long time to complete.

FINALWEIGHT names a new variable to contain the weight.

POPTOTAL can be specified as a number that the weights should sum to.

The DELTA, ITERATIONS, AND CONVERGENCE settings correspond to
the Genlog parameters.  The defaults are DELTA=.5, ITERATIONS=20,
CONVERGENCE= .0001.  If the generated weights do not produce the
required sample proportions, try setting DELTA=0.

By default, the table is checked for empty cells. CHECKEMPTY=NO skips that 
check, which can save time and memory.

By default, the GENLOG output and the auxiliary dataset generated by this
procedure are not shown.  SHOW=YES causes them to appear.

If the active dataset does not have a name, one is assigned by this procedure.

The output includes a table listing the raked weights and a table showing the
sample balance.  The balance is defined as
100 * sum(Wi,*Ri)**2 / (sum(Wi) * sum(WiRi**2))
where W is the input weight or 1 if unweighted, and R is the raked weight.
A balance of 100 means no adjustments to the input weights was required.
Although weights are computed for all cells, empty cells have no cases, so
the calculated weight is not shown in the output table as it is never used.

SPSSINC RAKE REGR /HELP.  prints this information and does nothing else.

This extension command requires the Python programmability plug-in, 
the rake.py module, and the SPSS Statistics Advanced Statistics option.
"""
#try:
    #import wingdbstub
#except:
    #pass

def Run(args):
    """Execute the SPSSINC RAKE command"""

    args = args[list(args.keys())[0]]
    ###print args   #debug

    oobj = Syntax([
        Template("DIM1", subc="",  ktype="literal", var="dim1", islist=True),
        Template("DIM2", subc="",  ktype="literal", var="dim2", islist=True),
        Template("DIM3", subc="",  ktype="literal", var="dim3", islist=True),
        Template("DIM4", subc="",  ktype="literal", var="dim4", islist=True),
        Template("DIM5", subc="",  ktype="literal", var="dim5", islist=True),
        Template("DIM6", subc="",  ktype="literal", var="dim6", islist=True),
        Template("DIM7", subc="",  ktype="literal", var="dim7", islist=True),
        Template("DIM8", subc="",  ktype="literal", var="dim8", islist=True),
        Template("DIM9", subc="",  ktype="literal", var="dim9", islist=True),
        Template("DIM10", subc="",  ktype="literal", var="dim10", islist=True),
        Template("POPTOTAL", subc="",  ktype="float", var="poptotal", vallist=(0,)),
        
        Template("DS", subc="DS1", ktype="varname", var="ds1"),
        Template("CATVAR", subc="DS1", ktype="varname", var="catvar1"),
        Template("TOTVAR", subc="DS1", ktype="varname", var="totvar1"),
        
        Template("DS", subc="DS2", ktype="varname", var="ds2"),
        Template("CATVAR", subc="DS2", ktype="varname", var="catvar2"),
        Template("TOTVAR", subc="DS2", ktype="varname", var="totvar2"),
        
        Template("DS", subc="DS3", ktype="varname", var="ds3"),
        Template("CATVAR", subc="DS3", ktype="varname", var="catvar3"),
        Template("TOTVAR", subc="DS3", ktype="varname", var="totvar3"),            

        Template("DS", subc="DS4", ktype="varname", var="ds4"),
        Template("CATVAR", subc="DS4", ktype="varname", var="catvar4"),
        Template("TOTVAR", subc="DS4", ktype="varname", var="totvar4"),            

        Template("DS", subc="DS5", ktype="varname", var="ds5"),
        Template("CATVAR", subc="DS5", ktype="varname", var="catvar5"),
        Template("TOTVAR", subc="DS5", ktype="varname", var="totvar5"),            
        
        Template("DS", subc="DS6", ktype="varname", var="ds6"),
        Template("CATVAR", subc="DS6", ktype="varname", var="catvar6"),
        Template("TOTVAR", subc="DS6", ktype="varname", var="totvar6"),            

        Template("DS", subc="DS7", ktype="varname", var="ds7"),
        Template("CATVAR", subc="DS7", ktype="varname", var="catvar7"),
        Template("TOTVAR", subc="DS7", ktype="varname", var="totvar7"),                       

        Template("DS", subc="DS8", ktype="varname", var="ds8"),
        Template("CATVAR", subc="DS8", ktype="varname", var="catvar8"),
        Template("TOTVAR", subc="DS8", ktype="varname", var="totvar8"),            
        Template("FINALWEIGHT", subc="", ktype="varname", var="finalweight"),

        Template("DS", subc="DS9", ktype="varname", var="ds9"),
        Template("CATVAR", subc="DS9", ktype="varname", var="catvar9"),
        Template("TOTVAR", subc="DS9", ktype="varname", var="totvar9"),            

        Template("DS", subc="DS10", ktype="varname", var="ds10"),
        Template("CATVAR", subc="DS10", ktype="varname", var="catvar10"),
        Template("TOTVAR", subc="DS10", ktype="varname", var="totvar10"),            
        
        Template("DELTA", subc="OPTIONS",  ktype="float", var="delta"),
        Template("ITERATIONS", subc="OPTIONS",  ktype="int", var="iter"),
        Template("CONVERGENCE", subc="OPTIONS",  ktype="float", var="conv"),
        Template("CHECKEMPTY", subc="OPTIONS", ktype="bool", var="checkempty"),
        Template("SHOW", subc="OPTIONS",ktype="bool", var="visible"),
        Template("SHOWWEIGHTS", subc="OPTIONS", ktype="bool", var="showweights"),
        
        Template("HISTOGRAM", subc="PLOT", ktype="bool", var="histogram"),
        Template("AUTOHEATMAP", subc="PLOT", ktype="int", var="autoheatmap",
            vallist=[2, 4]),
        Template("YVAR", subc="PLOT", ktype="existingvarlist", var="yvar"),
        Template("XVAR", subc="PLOT", ktype="existingvarlist", var="xvar"),
        Template("PANELDOWNVAR", subc="PLOT", ktype="existingvarlist", var="paneldownvar"),
        Template("PANELACROSSVAR", subc="PLOT", ktype="existingvarlist", var="panelacrossvar"),
        Template("HELP", subc="", ktype="bool")])

    #enable localization
    global _
    try:
        _("---")
    except:
        def _(msg):
            return msg
        # A HELP subcommand overrides all else
    if "HELP" in args:
        #print helptext
        helper()
    else:
        processcmd(oobj, args, rakeextension)

def helper():
    """open html help in default browser window
    
    The location is computed from the current module name"""
    
    import webbrowser, os.path
    
    path = os.path.splitext(__file__)[0]
    helpspec = "file://" + path + os.path.sep + \
         "markdown.html"
    
    # webbrowser.open seems not to work well
    browser = webbrowser.get()
    if not browser.open_new(helpspec):
        print(("Help file not found:" + helpspec))
try:    #override
    from extension import helper
except:
    pass        
def rakeextension(finalweight, dim1=None, dim2=None, dim3=None, dim4=None, dim5=None, 
    dim6=None, dim7=None, dim8=None, dim9=None, dim10=None, poptotal=None,
    ds1=None, catvar1=None, totvar1=None,
    ds2=None, catvar2=None, totvar2=None,
    ds3=None, catvar3=None, totvar3=None,
    ds4=None, catvar4=None, totvar4=None,
    ds5=None, catvar5=None, totvar5=None,
    ds6=None, catvar6=None, totvar6=None,
    ds7=None, catvar7=None, totvar7=None,
    ds8=None, catvar8=None, totvar8=None,
    ds9=None, catvar9=None, totvar9=None,
    ds10=None, catvar10=None, totvar10=None,
    yvar=None, xvar=None, paneldownvar=None, panelacrossvar=None, autoheatmap=None, histogram=True,
    delta=0, iter=20, conv=.0001, visible=False, showweights=True, checkempty=True):
    """dim1 through dim10 are lists with control specifications for up to ten variables.  Each must have the form
    varname value, tot, value, tot, ...
    where value is a number and tot is the fraction or absolute total for the value."""
    #try:  #debug
        #import wingdbstub
        #if wingdbstub.debugger != None:
            #import time
            #wingdbstub.debugger.StopDebug()
            #time.sleep(2)
            #wingdbstub.debugger.StartDebug()
        #import thread
        #wingdbstub.debugger.SetDebugThreads({thread.get_ident(): 1}, default_policy=0)
        ## for V19 use
        ##    ###SpssClient._heartBeat(False)
    #except:
        #pass    

    encoding = locale.getlocale()[1]  # for code page conversions
    ###cvs = [item[0] for item in (dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10) if item]
    ###vardict = spssaux.VariableDict(cvs + [poptotal]+ [finalweight])

    # assemble list of control variables and list of dictionaries of totals for each control variable value
    dims = [dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10]
    dss = [ds1, ds2, ds3, ds4, ds5, ds6, ds7, ds8, ds9, ds10]
    catvars = [catvar1, catvar2, catvar3, catvar4, catvar5, catvar6, catvar7, catvar8, catvar9, catvar10]
    totvars = [totvar1, totvar2, totvar3, totvar4, totvar5, totvar6, totvar7, totvar8, totvar9, totvar10]
    
    ctlvars, ctltotals = buildspec(dims, dss, catvars, totvars, encoding, finalweight)

    info = NonProcPivotTable(omssubtype="INFORMATION", procname="SPSSINC RAKE",
        tabletitle=_("Information"))
    rake(info, ctlvars, ctltotals, finalweight, visible, showweights, poptotal, 
        delta, iter, conv, checkempty,
        yvar, xvar, paneldownvar, panelacrossvar, autoheatmap, histogram)

def buildspec(dims, dss, catvars, totvars, encoding, finalweight):
    """create raking specification and return control variable list and totals list
    
    dims is a list of dimension variables, categories, and totals
    dss, catvars, and totvars are alternative ways of specifying the same information
    dss is a list of dataset names, catvars a list of category variable names, and 
    totvars a list of the corresponding control totals"""
    
    vardict = spssaux.VariableDict()
    if finalweight in vardict:
        raise ValueError(_("FINALWEIGHT cannot specify an existing variable name"))    
    ctlvars= []
    ctltotals = []
    activedsname = spss.ActiveDataset()
    if activedsname == "*": #unnamed
        activedsname = "D" + str(random.uniform(.1,1))
        spss.Submit("DATASET NAME %s" % activedsname)

    for dim in dims:    
        if dim:
            v = dim
            if not isinstance(v[0], str):
                vvname = str(v[0], encoding)
            else:
                vvname = v[0]
            if not v[0] in vardict:
                raise ValueError(_("A control total variable does not exist: %s") % vvname)
            if not vardict[v[0]].VariableType == 0:
                raise ValueError(_("A nonnumeric variable was specified for a control dimension: %s") % vvname)
            if len(v) == 1 or not len(v) % 2 == 1:
                raise ValueError(_("An invalid set of values and totals was found for a control dimension: %s") % " ".join(v))
            ctlvars.append(v[0])
            #ctltotals.append(dict([(float(k),float(v)) for k,v in zip(v[1::2], v[2::2])]))
            try:
                # category totals can be numerical expressions
                # convert to a value after insuring that all numbers are floats
                ctltotals.append(dict([(float(k), float(eval(decimalize(v)))) for k,v in zip(v[1::2], v[2::2])]))
            except:
                raise ValueError(_("""Invalid category or category total for variable: %s""") % vvname)
    for i, ds in enumerate(dss):
        catvar = catvars[i]
        totvar = totvars[i]
        if not any([ds, catvar, totvar]):
            continue
        if ds and (catvar is None or totvar is None):
            raise ValueError(_("""A dataset was specified without the category or totals variable names: %s""") % ds)
        try:
            spss.Submit("DATASET ACTIVATE %s" % ds)
            dta = spssdata.Spssdata([catvar, totvar], names=False).fetchall()
            ctlvars.append(catvar)
            # A dataset value might be simply numeric or a string expression
            ctltotals.append(dict([(float(k), float(eval(decimalize((v))))) for k,v in dta]))
        except: # error conditions include nonexistant dataset and variables and type problems
            spss.Submit("DATASET ACTIVATE %s" % activedsname)
            raise
    spss.Submit("DATASET ACTIVATE %s" % activedsname)
    if not ctlvars:
        raise ValueError(_("""No raking specifications were given"""))
    # check for duplicate control variables
    ctllc = [v.lower() for v in ctlvars]
    ctlset = set(ctllc)
    if len(ctllc) != len(ctlset):  # any duplicates?
        for v in ctlset:
            ctllc.remove(v)
        raise ValueError(_("""Duplicate control variables were specified: %s""") % ", ".join(set(ctllc)))
    return ctlvars, ctltotals


def rake(info, variables, marginals,finalweight, visible=False, showweights=True, 
        poptotal=None, delta=0, iter=20, conv=.0001,checkempty=True,
        yvar=None, xvar=None, paneldownvar=None, panelacrossvar=None, autoheatmap=None, histogram=True):
    """Calculate a weight variable such that for each controlled dimension, the (weighted) count in each category matches a specified total or fraction.
e    variables is a list of the variables for which control totals or proportions are provided.  It can be a sequence or
    a white-space separated string
    marginals is a list of dictionaries where the key is the value of a variable and the value is the target control total or fraction.
    fractional marginals should normally add to 1 and counts should total the same in each dimension, but this is not enforced.
    If there are no cases for a given value, the total or fraction will be less than expected.
    Negative and zero marginals are tolerated but are generally inappropriate.  
    If a control value is not in the appropriate marginals dictionary or is zero, the resulting weight will be SYSMIS.

    finalweight is a string naming the new weight variable.  The variable must not already exist in the active dataset.
    visible indicates whether or not the procedure output and auxiliary dataset are displayed.
    poptotal is a total to which the final weights will be scaled.  By default, they are scaled to sum to the existing weight total, if any, or the number of cases.
    delta, iter, and conv are iteration parameters corresponding to the GENLOG parameters and can be used if there are convergence problems.
    checkempty adjusts for empty cells.  If it is known that there are none, this adjustment, which can use considerable memory, can be bypassed.
    If the active dataset does not have a name, one is assigned automatically."""

    variables = _buildvarlist(variables)
    if len(variables) == 1:   # delta should always be 0 if this is a 1-d problem
        delta = 0.
    wtvar = spss.GetWeightVar()
    if wtvar:  #aggrweight will be the GENLOG CSTRUCTURE variable
        aggrweight = "W_" + rname()
    else:
        aggrweight = "N_" + rname()
    activeds = spssaux.GetActiveDatasetName()
    if not activeds:
        activeds = "D_" + rname()
        spss.Submit("DATASET NAME " + activeds)
    nbreakvars = len(variables)
    if nbreakvars != len(marginals):
        raise ValueError(_("The number of control variables does not match number of sets of control totals"))

    # aggregate the data according to the list of control variables
    aggrdsname = "D_" + rname()
    countname = "N_" + rname()
    spss.Submit("WEIGHT OFF.")
    # aggregate to a new dataset and activate it.  Sum original weight variable if any
    cmd=\
       """DATASET DECLARE  %(aggrdsname)s %(vis)s.
    AGGREGATE 
     /OUTFILE= %(aggrdsname)s
     /BREAK=%(breakvars)s
    %(wtspec)s 
    /%(countname)s=N.
   dataset activate %(aggrdsname)s.""" % \
                                       {'aggrdsname': aggrdsname,
                                        'breakvars' : " ".join(variables),
                                        'wtspec' : ("/" + aggrweight + (wtvar and ("= SUM(" + wtvar + ")") or "= N")),
                                        'countname' : countname,
                                        'vis' : visible and " " or " WINDOW=HIDDEN"
                                        }
    spss.Submit(cmd)
    # if weighting, make a dictionary of the mean weight in each cell for use in final adjustment pass
    if wtvar:
        allaggrdata = spssdata.Spssdata(variables + [aggrweight] + [countname]).fetchall()
        meaninputwts = {}
        for row in allaggrdata:
            try:
                themean = row[nbreakvars] / row[nbreakvars+1]
            except:
                themean = None
            meaninputwts[row[:nbreakvars]] = themean
        

    # get a cursor and add control totals to this dataset
    # The control total is the product of all the variable value control totals or proportions
    # Track the cases to see if there are any empty cells, i.e., some combination of the marginals across
    # all the control variables that does not occur in the aggregated dataset.
    spss.StartProcedure("SPSSINC RAKE - I")
    if checkempty:
        cellset = _setprod(_dictlisttotupledsets(marginals))   # build set of tuples of all sets
        curs = spssdata.Spssdata(accessType='r', indexes=variables, names=False)
        for case in curs:
            cellset.discard(tuple(case[:nbreakvars]))  # remove found cells
        curs.CClose()
        spss.EndProcedure()
        #add cases for any empty cells
        if cellset:
            spss.StartProcedure("SPSSINC RAKE - I")
            curs = spssdata.Spssdata(accessType='a', names=False)
            for s in cellset:
                for cv in range(nbreakvars):
                    curs.appendvalue(cv, s[cv])
                for cv in range(2):  #was nbreakvars
                    curs.appendvalue(nbreakvars+cv, 1e-12)   # 1e-8
                curs.CommitCase()
            curs.CClose()
            spss.EndProcedure()

        # compute expected count from marginals
    try:
        curs = spssdata.Spssdata(accessType='w')
        ctrlwt = "W_"+ rname()  # this will be the SPSS case weight
        curs.append(ctrlwt)
        curs.commitdict()
        novalues = []
        for case in curs:
            w = 1.
            for i, v in enumerate(marginals):
                w = w* v.get(case[i], 0)
                if w == 0:
                    spec = (variables[i], case[i])
                    if not spec in novalues:
                        uspec = spec[0]
                        if not isinstance(uspec, str):
                            uspec = str(uspec, locale.getlocale()[1])
                        info.addrow(_("Variable: %s, value: %s. No control value supplied: weight will be SYSMIS.") % (uspec,  spec[1]))
                    novalues.append(spec)
                    break
            curs.casevalues([w])
    finally:
        curs.CClose()
        spss.EndProcedure()
        info.generate()

    # run GENLOG
    expectedname = 'expected_' + rname()
    newwt = "W_"+ rname()
    #dbg
    ###spss.Submit("""save outfile="c:/temp/genloginput.sav".""")
    if not visible:
        omstag = "O_" + rname()
        spss.Submit("OMS /SELECT ALL EXCEPT =WARNINGS /DESTINATION VIEWER=NO /TAG=" + omstag)
    #debugcmd =  """WEIGHT BY %(ctrlwt)s.
        #GENLOG
        #%(breakvars)s  /CSTRUCTURE = %(aggrweight)s
        #/MODEL = POISSON
        #/PRINT = FREQ ESTIM
        #/plot none
        #/CRITERIA = CIN(95) ITERATE(%(iter)s) CONVERGE(%(conv)s) DELTA(%(delta)s)
       #/save= pred(%(expectedname)s)
        #/DESIGN %(breakvars)s .  """ %\
                                     #{'ctrlwt' : ctrlwt,
                                      #'breakvars': " ".join(variables),
                                      #'aggrweight' : aggrweight ,
                                      #'expectedname' : expectedname,
                                      #'iter' : iter,
                                      #'conv' : conv,
                                      #'delta' : delta
                                      #}

    try:
        spss.Submit("""WEIGHT BY %(ctrlwt)s.
            GENLOG
            %(breakvars)s  /CSTRUCTURE = %(aggrweight)s
            /MODEL = POISSON
            /PRINT = FREQ ESTIM
            /plot none
            /CRITERIA = CIN(95) ITERATE(%(iter)s) CONVERGE(%(conv)s) DELTA(%(delta)s)
           /save= pred(%(expectedname)s)
            /DESIGN %(breakvars)s .  """ %\
                                         {'ctrlwt' : ctrlwt,
                                          'breakvars': " ".join(variables),
                                          'aggrweight' : aggrweight ,
                                          'expectedname' : expectedname,
                                          'iter' : iter,
                                          'conv' : conv,
                                          'delta' : delta
                                          })
    except:
        spss.Submit("DATASET ACTIVATE " + activeds)
        raise ValueError(_("""Failure in GENLOG procedure.  Processing stopped.
        The error could be either a failure to compute the result 
        or not having a license for the Advanced Statistics option"""))
    finally:
        if not visible:
            spss.Submit("OMSEND TAG=" + omstag)
    # get the expected counts, normalized by the cell N in order to distribute
    expkts = {}
    spss.StartProcedure("SPSSINC RAKE - II")

    try:
        curs = spssdata.Spssdata(accessType='r', indexes = variables + [expectedname] + [aggrweight]+ [countname])
        weightsum = 0.
        wsum = 0.
        for case in curs:
            weightsum += case[nbreakvars] or 0  # allow for missing values j.i.c
            if case[-3]:
                wsum += case[-2]
                w = case[-3]/case[-1]
            else:
                w = None
            expkts[tuple(case[:nbreakvars])] = w
    finally:
        curs.CClose()
        spss.EndProcedure()
    # normalize weights to user total or sum of sample weights
    poptotal = poptotal or wsum
    for key in expkts:
        if expkts[key]:
            expkts[key] *= poptotal/weightsum

    # return to the first dataset and apply weights.
    spss.Submit("DATASET ACTIVATE " + activeds)
    if not visible:
        spss.Submit("DATASET CLOSE " + aggrdsname)
    spss.StartProcedure("SPSSINC RAKE - III")
    if wtvar:
        indexes = variables+ [wtvar]
    else:
        indexes = variables
    curs = spssdata.Spssdata(accessType='w', indexes = indexes)
    try:
        failed = False
        curs.append(spssdata.vdef(finalweight, vlabel=_("Raked Weight")))
        curs.commitdict()
        wirisum = 0.
        wirisumNewwt = 0.
        wiri2sum = 0.
        wiri2sumNewwt = 0.
        wisum = 0.
        actuals = {}   # dictionary for weights and counts actually used
        actualsNewwt = {}

        for case in curs:
            index = case[:nbreakvars]
            rwt = expkts.get(index, None)   # raked weight
            if wtvar:
                wt = case[-1]
            else:
                wt = 1.
            # for weighted data, adjust cell weights by input case weight normalized by cell mean weight
            try:
                if wtvar:
                    newwt = rwt * wt / meaninputwts[index]
                else:
                    newwt = rwt
            except:
                newwt = None
            curs.casevalues([newwt])
            #curs.casevalues([rwt])
            try:
                kt = actuals.get(index, (0,0))[1] + wt
                actuals[index] = [rwt, kt]
            except: 
                pass
            if wtvar:
                try:
                    cumwt, cumkt = actualsNewwt.get(index, [0,0])
                    cumwt += newwt
                    cumkt += wt
                    #cumkt += 1
                    actualsNewwt[index] = [cumwt, cumkt]
                except:
                    pass

            if not rwt is None:
                wisum += wt
                wirisum += wt * newwt
                wiri2sum += wt * newwt * newwt

    except:
        curs.CClose()
        curs = None
        spss.EndProcedure()
        raise
    finally:
        if not curs is None:
            curs.CClose()
    denom = wisum * wiri2sum
    if denom != 0:
        sampleeff = 100. * wirisum * wirisum / denom
    else:
        sampleeff = None
    cells = [sampleeff]
    rowlabels = [_("""Sample Balance""")]
    if wtvar:
        #denom = wisum * wiri2sumNewwt
        #if denom != 0:
            #sampleeffNewwt = 100. * wirisumNewwt * wirisumNewwt / denom
        #else:
            #sampleeffNewwt = None
        #cells.append(sampleeffNewwt)
        rowlabels = [_("""Sample Balance Including Final Weight Adjustment""")]
    tbl = spss.BasePivotTable(_("""Sample Balance Based on Variables: %s""") % ", ".join(variables), 
        "RAKEBALANCE")
    tbl.SimplePivotTable(rowlabels=rowlabels, collabels=[_("""Balance""")], cells=cells)
    
    # table of weights
    if showweights:
        collabels = [_("""Category Rake Weight""")]
        if wtvar:
            for k in actuals:
                cumwt, cumkt = actualsNewwt[k]
                act = actuals[k]
                act.append(cumwt / cumkt)
                actuals[k] = act
            collabels.append(_("Case Count Weighted by Input Weight"))
            collabels.append(_("Mean Adjusted Raked Weight"))
        else:
            collabels.append(_("Unweighted Case Count"))
        #items = sorted(expkts.items())
        items = sorted(actuals.items())
        rowlabels = [", ".join([str(v) for v in item[0]]) for item in items]
        cells = [item[-1] for item in items]
    
        tbl2 = spss.BasePivotTable(_("""Raked Weights"""), "RAKEDWEIGHTS")
        tbl2.SimplePivotTable(rowdim=", ".join(variables), rowlabels = rowlabels, 
            collabels=collabels, cells=cells)
    spss.EndProcedure()
    if not failed:
        if histogram:
            dohistogram(finalweight)
        doheatmap(variables, yvar, xvar, paneldownvar, panelacrossvar, finalweight, autoheatmap)
        spss.Submit("WEIGHT BY " + finalweight)

def rname():
    return str(random.uniform(0.1, 1))

def fixer(mobj):
    """ensure that the number string has a decimal
    
    mobj is an re match object"""
    
    item = mobj.group(0)
    if "." in item:
        return item
    else:
        return item + "."
    
def decimalize(xpr):
    "Avoid integer arithmetic"
    
    if not isinstance(xpr, str):
        return str(xpr)
    return re.sub(r"\.*\d+\.*\d*", fixer, xpr)


def _buildvarlist(arg):
    """return a list of (presumed) variable names.

    arg can be any sequence, including an spssaux VariableDict or a string of white-space separated names"""
    if spssaux._isseq(arg):
        return list(arg)
    else:
        return re.split("[ \t,\n]+", arg)

def _setprod(setlist):
    """Return a set whose members are tuples of all combinations of the input sets.

    setlist is a list of sets.  All the set members should be tuples."""
    res = set(setlist[0])
    for i in range(1, len(setlist)):
        res = set([item + a for item in res for a in setlist[i]])
    return res

def _dictlisttotupledsets(dlist):
    """Return a list of sets for which set consists of tuples.

    dlist is a list of dictionaries.  The keys are extracted and made into sets of tuples"""

    res = []
    for d in dlist:
        res.append(set([(k,) for k in d]))
    return res

# specifications for heatmap syntax
# be careful to avoid generating any blank lines within the command

hmtemplate = """GGRAPH
  /GRAPHDATASET NAME="graphdataset"
    VARIABLES=%(yvar)s[LEVEL=nominal] %(xvar)s[LEVEL=ordinal]  
    %(finalweightvar)s[LEVEL=scale] %(panelingdownvars)s %(panelingacrossvars)s
    MISSING=LISTWISE REPORTMISSING=NO
  /GRAPHSPEC SOURCE=VIZTEMPLATE(NAME="Heat Map"[LOCATION=LOCAL]
    MAPPING( %(panelingdowntem)s "color"="%(finalweightvar)s"[DATASET="graphdataset"] 
    "columns"="%(yvar)s"[DATASET="graphdataset"] %(panelingacrosstem)s 
    "rows"="%(xvar)s"[DATASET="graphdataset"] "Title"="%(title)s"))
    VIZSTYLESHEET="Traditional"[LOCATION=LOCAL]
    LABEL="%(label)s"
    DEFAULTTEMPLATE=NO."""

def doheatmap(variables, yvar, xvar, paneldownvar, panelacrossvar, finalweightvar, autoheatmap):
    """produce a heatmap of the weights with 2 to 4 variables if requested
    
    variables is the set of variables with control totals
    yvar and xvar are the main variables for the heatmap (as lists)
    paneldownvar and panelacrossvar are variables for paneling down and across
    finalweightvar is the output weight variable
    autoheatmap specifies that the first two to four control variables
    define the heatmap dimensions"""
    
    # autoheatmap is used to get around dialog box limitations and overrides other
    # related variable specifications without a warning
    
    if len(variables) == 1:
        return    # No heatmap available
    if autoheatmap:
        yvar = [variables[0]]
        xvar = [variables[1]]
        hmsize = min(autoheatmap, len(variables), 4)
        if hmsize >=3:
            paneldownvar = [variables[2]]
        else:
            paneldownvar = None
        if hmsize >=4:
            panelacrossvar = [variables[3]]
        else:
            panelacrossvar = None
    
    plotvars = (yvar, xvar, paneldownvar, panelacrossvar)
    
    if not any(plotvars):
        return    # no plot requested
    if not all([yvar, xvar]):
        print(_("No heatmap produced: both y and x variables must be specified"))
        return
    if set(v[0] for v in plotvars if v is not None) - set(variables):
        print(_("No heatmap produced: only raking variables can be specified"))
        return
    if not paneldownvar:
        panelingdownvars = ""
        panelingdowntem = ""
    else:
        panelingdownvar = paneldownvar[0]
        panelingdownvars = """%(panelingdownvar)s[LEVEL=nomimal]""" % locals()
        panelingdowntem = """ "Panel down"="%(panelingdownvar)s"[DATASET="graphdataset"]""" % locals()
    if not panelacrossvar:
        panelingacrossvars = ""
        panelingacrosstem = ""
    else:
        panelingacrossvar = panelacrossvar[0]
        panelingacrossvars = """%(panelingacrossvar)s[LEVEL=nomimal]""" % locals()
        panelingacrosstem = """ "Panel across"="%(panelingacrossvar)s"[DATASET="graphdataset"]""" % locals()
    title = _("Unweighted Heatmap of Weights by Raking Variables")
    label = _("Weight Heatmap")
    yvar = yvar[0]
    xvar = xvar[0]
    cmd = hmtemplate % locals()
    spss.Submit(cmd)
    
    
# histogram template
# parameters are finalweight and title
histtem="""GGRAPH
    /GRAPHDATASET NAME="graphdataset"
        VARIABLES=%(finalweightvar)s[LEVEL=scale] 
        MISSING=LISTWISE REPORTMISSING=NO
    /GRAPHSPEC SOURCE=VIZTEMPLATE(NAME="Histogram"[LOCATION=LOCAL]
                                  MAPPING( "x"="%(finalweightvar)s"[DATASET="graphdataset"] "Summary"="count" "Title"='%(title)s'))
        VIZSTYLESHEET="Traditional"[LOCATION=LOCAL]
        LABEL='HISTOGRAM of Weights'
        DEFAULTTEMPLATE=NO."""

def dohistogram(finalweightvar):
    """Display unweighted histogram of weights
    
    finalweightvar is the generated weight variable"""
    
    title = _("Raked Weights Histogram before Applying New Weights")
    cmd = histtem % locals()
    spss.Submit(cmd)
    
class NonProcPivotTable(object):
    """Accumulate an object that can be turned into a basic pivot table once a procedure state can be established"""
    
    def __init__(self, omssubtype, outlinetitle="", tabletitle="", caption="", rowdim="", coldim="", columnlabels=[],
                 procname="Messages"):
        """omssubtype is the OMS table subtype.
        caption is the table caption.
        tabletitle is the table title.
        columnlabels is a sequence of column labels.
        If columnlabels is empty, this is treated as a one-column table, and the rowlabels are used as the values with
        the label column hidden
        
        procname is the procedure name.  It must not be translated."""
        
        attributesFromDict(locals())
        self.rowlabels = []
        self.columnvalues = []
        self.rowcount = 0

    def addrow(self, rowlabel=None, cvalues=None):
        """Append a row labelled rowlabel to the table and set value(s) from cvalues.
        
        rowlabel is a label for the stub.
        cvalues is a sequence of values with the same number of values are there are columns in the table."""
        
        if cvalues is None:
            cvalues = []
        self.rowcount += 1
        if rowlabel is None:
            self.rowlabels.append(str(self.rowcount))
        else:
            self.rowlabels.append(rowlabel)
        self.columnvalues.extend(cvalues)
        
    def generate(self):
        """Produce the table assuming that a procedure state is now in effect if it has any rows."""
        
        privateproc = False
        if self.rowcount > 0:
            try:
                table = spss.BasePivotTable(self.tabletitle, self.omssubtype)
            except:
                spss.StartProcedure(self.procname)
                privateproc = True
                table = spss.BasePivotTable(self.tabletitle, self.omssubtype)
            if self.caption:
                table.Caption(self.caption)
            if self.columnlabels != []:
                table.SimplePivotTable(self.rowdim, self.rowlabels, self.coldim, self.columnlabels, self.columnvalues)
            else:
                table.Append(spss.Dimension.Place.row,"rowdim",hideName=True,hideLabels=True)
                table.Append(spss.Dimension.Place.column,"coldim",hideName=True,hideLabels=True)
                colcat = spss.CellText.String("Message")
                for r in self.rowlabels:
                    cellr = spss.CellText.String(r)
                    table[(cellr, colcat)] = cellr
            if privateproc:
                spss.EndProcedure()
                
def attributesFromDict(d):
    """build self attributes from a dictionary d."""
    self = d.pop('self')
    for name, value in d.items():
        setattr(self, name, value)
